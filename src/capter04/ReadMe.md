#类和接口
- 使类和成员的可访问性最小化
>它可以有效的解除组成系统的各模块之间的耦合关系，使得这些模块可以独立开发、测试、优化、使用、理解和修改。这样可加快系统开发的速度，因为这些模块可以并行开发。他也减轻了维护的负担，因为程序
员可以更快的理解这些模块，并且可以在调试它们的时候可以不影响其他模块。虽然信息隐藏本身无论是对内还是对外，都不会带来更好的性能，但是它可以有效的调节性能：一旦完成一个系统，并通过剖析确定了哪些
模块影响了系统的性能，那些模块就可以进一步优化，而不会影响其他模块的正确性。最后，信息隐藏也降低了构建大型系统的风险，因为即使整个系统不可用，但是这些独立的模块却是可能可用的  

>尽可能地使每个类或者成员不被外界访问  
>实例域绝不能是公有的，包含公有可变域的类并不是线程安全的  

- 在公有类中使用访问而非共有yu
> 如果类可以在它所在的包的外部进行访问，就提供访问方法；如果类是包级私有的，或者是私有的嵌套类，直接暴露他的数据域并没有本质错误  

- 使可变性最小化
> 为了使类称为不可变，要遵循下面五条规则：
>>不要提供任何会修改对象状态的方法  
>>保证类不会被扩展  
>>使所有的域都是final的  
>>使所有的域都成为私有的
>>确保对于任何可变组件的互斥访问

- 复合优先于继承
>继承打破了封装性，子类依赖于其超类中特定功能的实现细节。超类的实现可能随着发行版本的不同而有所变化，如果真的发生变化，子类可能会遭到破坏，因此子类必须要跟着超类的更新而演变，除非
超类是专门为了扩展而设计，并且有很好的文档说明。  
>导致子类脆弱的另一个相关原因是，他们的超类在后序的发行版本中可以获得新的方法。  
>避免方法：使用复合。不用扩展现有的类，而是在新类中增加一个私有域

- 要么为继承设计，并提供文档说明，要么就禁止继承
>为了允许继承，类必须遵循一些约束，构造器决不能调用可被覆盖的方法，无论是直接调用还是间接调用。如果违反了这个规则，则可能导致程序失败。超类的构造器在子类的构造器之前运行，所以，
子类中覆盖版本的方法将会在子类的构造器运行之前就先被调用。

- 接口优于抽象类

- 接口只用于定义类型

- 类层次优于标签类
>标签类过于冗长，容易出错，并且效率低下。标签类是类层次的一种简单的仿效。java提供了其他更好的方法来定义能表示多种风格对象的数据类型：子类型化。标签类正是类层次的一种简单的仿效

- 用函数对象表示策略

- 优先考虑静态成员类